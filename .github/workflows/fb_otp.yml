name: FB OTP Automation

on:
  workflow_dispatch:
    inputs:
      numbers:
        description: Phone numbers one per line
        required: false
        type: string
      mode:
        description: 'Mode: run or ping'
        required: false
        default: 'run'
        type: string



jobs:
  ping-check:
    if: ${{ github.event.inputs.mode == 'ping' }}
    runs-on: ubuntu-latest
    steps:
      - name: Send Ping
        run: |
           curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" --data-urlencode "text=‚úÖ Server (${{ github.repository }}) is Online and Working!"

  prepare-matrix:
    if: ${{ github.event.inputs.mode == 'run' || github.event.inputs.mode == '' }}
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Generate Matrix
        id: set-matrix
        run: |
          # Get input numbers, remove empty lines
          INPUT_NUMBERS="${{ github.event.inputs.numbers }}"
          
          # Create JSON array of chunks (batches of 5)
          # We use python for easier JSON handling
          MATRIX_JSON=$(python3 -c "
          import json
          import sys
          
          input_str = '''$INPUT_NUMBERS'''
          numbers = [n.strip() for n in input_str.split('\n') if n.strip()]
          
          # Chunk size = 1 (One number per job as requested)
          chunk_size = 1
          chunks = [numbers[i:i + chunk_size] for i in range(0, len(numbers), chunk_size)]
          
          # Create list of objects for matrix, e.g. [{'chunk': 'num1'}]
          matrix = [{'numbers': '\\n'.join(chunk), 'id': i+1} for i, chunk in enumerate(chunks)]
          
          # SAFETY: If matrix is empty (no numbers), add a dummy entry to prevent workflow error
          if not matrix:
             matrix = [{'numbers': '', 'id': '0'}]
             
          print(json.dumps(matrix))
          ")
          
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
          echo "Generated Matrix: $MATRIX_JSON"

  process-numbers:
    needs: prepare-matrix
    if: ${{ github.event.inputs.mode == 'run' || github.event.inputs.mode == '' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4


      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
      
      - name: Install Chrome
        uses: browser-actions/setup-chrome@latest
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y openvpn dialog python3-pip expect wget
          pip install selenium webdriver-manager requests

      - name: Connect to ProtonVPN (Random Server)
        env:
          PROTON_USER: ${{ secrets.PROTON_USER }}
          PROTON_PASSWORD: ${{ secrets.PROTON_PASS }}
        run: |
          # Initialize ProtonVPN (OpenVPN Direct)
          # We bypass the CLI tools (Community=422, Official=DBus/Keyring issues) and use OpenVPN directly.
          echo "Setting up OpenVPN..."
          sudo apt-get install -y openvpn
          
          # Create Auth File
          echo "${{ secrets.PROTON_USER }}" > vpn-auth.txt
          echo "${{ secrets.PROTON_PASS }}" >> vpn-auth.txt
          chmod 600 vpn-auth.txt
          
          # Download generic free server configs (US)
          # Source: https://github.com/alefvanoon/Proton-Free-OVPN
          # We try a few servers in case one is down.
          SERVERS=("us-va-104.protonvpn.com.udp.ovpn" "us-va-105.protonvpn.com.udp.ovpn" "us-va-106.protonvpn.com.udp.ovpn")
          BASE_URL="https://raw.githubusercontent.com/alefvanoon/Proton-Free-OVPN/master"
          
          CONNECTED=false
          set +e  # Disable errexit for connection loop
          for SERVER in "${SERVERS[@]}"; do
            echo "Attempting to connect to $SERVER..."
            # Download with fail flag
            if ! curl -sSL -f "$BASE_URL/$SERVER" -o vpn-config.ovpn; then
               echo "Download failed for $SERVER"
               continue
            fi
            
            if [ ! -s vpn-config.ovpn ]; then
               echo "Downloaded file is empty: $SERVER"
               continue
            fi
            
            # Fix: OpenVPN 2.6 strict ordering.
            # Catch python errors to avoid workflow exit
            if ! python3 -c "import sys; lines=sys.stdin.readlines(); conns=[i for i,l in enumerate(lines) if '<connection>' in l or '</connection>' in l]; start=conns[0]; end=conns[-1]; print(''.join(lines[:start] + lines[end+1:] + lines[start:end+1]))" < vpn-config.ovpn > fixed.ovpn; then
               echo "Reorder script failed for $SERVER. File content:"
               head -n 20 vpn-config.ovpn || true
               continue
            fi
            mv fixed.ovpn vpn-config.ovpn
            
            # Start OpenVPN in background with logging
            sudo openvpn --config vpn-config.ovpn --auth-user-pass vpn-auth.txt --daemon --log vpn.log
            
            # Wait for connection
            echo "Waiting for VPN connection..."
            for i in {1..15}; do
               if ip addr show tun0 > /dev/null 2>&1; then
                  echo "VPN Interface tun0 is up!"
                  # Double check connectivity
                  sleep 5
                  CURRENT_IP=$(curl -s --max-time 5 https://api.ipify.org || echo "unknown")
                  echo "Current IP: $CURRENT_IP"
                  if [ "$CURRENT_IP" != "unknown" ]; then
                     CONNECTED=true
                     break 2
                  fi
               fi
               sleep 2
            done
            
            echo "Connection failed or timed out. Killing OpenVPN..."
            echo "--- VPN Log ---"
            cat vpn.log 2>/dev/null || echo "No log file found"
            echo "--- End VPN Log ---"
            sudo killall openvpn || true
            rm vpn-config.ovpn vpn.log 2>/dev/null || true
            sleep 2
          done
          set -e  # Re-enable errexit
          
          if [ "$CONNECTED" = false ]; then
             echo "Error: Could not connect to any ProtonVPN server."
             exit 1
          fi
          
          echo "VPN Connected Successfully."
      
      - name: Get IP and WARP Status
        id: ip
        run: |
           echo "ip=$(curl -s ifconfig.me)" >> $GITHUB_OUTPUT
           TRACE=$(curl -s https://www.cloudflare.com/cdn-cgi/trace)
           if echo "$TRACE" | grep -q "warp=on"; then
             echo "warp_status=‚úÖ Active" >> $GITHUB_OUTPUT
           else
             echo "warp_status=‚ùå Inactive" >> $GITHUB_OUTPUT
           fi
      
      - name: Create batch file
        run: |
          echo "${{ matrix.numbers }}" > numbers.txt
          echo "Processing Batch #${{ matrix.id }}"
          cat numbers.txt

          
      - name: Send Start Message
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          BATCH_ID: ${{ matrix.id }}
          IP: ${{ steps.ip.outputs.ip }}
        run: |
          python3 -c "
          import os, requests
          try:
              token = os.environ['TELEGRAM_TOKEN']
              chat_id = os.environ['TELEGRAM_CHAT_ID']
              batch_id = os.environ['BATCH_ID']
              ip = os.environ.get('IP', 'Unknown')
              
              with open('numbers.txt', 'r') as f:
                  count = len([l for l in f if l.strip()])
              
              msg = f'üöÄ Batch #{batch_id} Started ({count} numbers)\nüåç IP: {ip}\nüõ°Ô∏è VPN: ‚úÖ Proton (WireGuard)'
              requests.post(f'https://api.telegram.org/bot{token}/sendMessage', data={'chat_id': chat_id, 'text': msg})
              print('Start message sent successfully')
          except Exception as e:
              print(f'Failed to send message: {e}')
          "
      
      - name: Run OTP Script (Batch)
        id: otp
        continue-on-error: true
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          IP="${{ steps.ip.outputs.ip }}"
          while IFS= read -r number || [ -n "$number" ]; do
            [ -z "$number" ] && continue
            echo "Processing: $number"
            result=$(python fb_otp_browser.py "$number" --headless 2>&1 || true)
            echo "$result"
            
            # Status Check with Reason Extraction
            if echo "$result" | grep -qi "OTP_SENT"; then
              status="‚úÖ OTP Sent"
            else
              # Try to get specific failure reason
              fail_reason=$(echo "$result" | grep "FINAL_STATUS_MSG:" | tail -1 | sed 's/FINAL_STATUS_MSG: //')
              if [ -n "$fail_reason" ] && [ "$fail_reason" != "Unknown Error" ]; then
                status="‚ùå $fail_reason"
              elif echo "$result" | grep -qi "FAILED"; then
                status="‚ùå Failed (Generic)"
              else
                status="‚ö†Ô∏è Check Logs"
              fi
            fi
            
            # Extract URL
            last_url=$(echo "$result" | grep -E "Final URL:|Last URL:" | tail -1 | sed 's/.*URL: //' || echo "")
            
            if [ -n "$last_url" ]; then
              msg="Batch #${{ matrix.id }} | $number - $status | URL: $last_url"
            else
              msg="Batch #${{ matrix.id }} | $number - $status | IP: $IP"
            fi
            
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage" -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" --data-urlencode "text=$msg"
            sleep 1
          done < numbers.txt
      
      - name: Send Completion Message
        if: always()
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          BATCH_ID: ${{ matrix.id }}
          REPO: ${{ github.repository }}
        run: |
          python3 -c "
          import os, requests
          try:
              token = os.environ['TELEGRAM_TOKEN']
              chat_id = os.environ['TELEGRAM_CHAT_ID']
              batch_id = os.environ['BATCH_ID']
              repo_name = os.environ['REPO']
              
              with open('numbers.txt', 'r') as f:
                  count = len([l for l in f if l.strip()])
              
              msg = f'‚úÖ Server {repo_name} | Batch #{batch_id} Completed! ({count} numbers)'
              requests.post(f'https://api.telegram.org/bot{token}/sendMessage', data={'chat_id': chat_id, 'text': msg})
              print('Completion message sent successfully')
          except Exception as e:
              print(f'Failed to send completion message: {e}')
          "